

# This file was *autogenerated* from the file sol.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_255 = Integer(255); _sage_const_19 = Integer(19); _sage_const_486662 = Integer(486662); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_9 = Integer(9); _sage_const_3 = Integer(3); _sage_const_0x1337c0decafe = Integer(0x1337c0decafe)
p = _sage_const_2 **_sage_const_255  - _sage_const_19 
A = _sage_const_486662 
B = _sage_const_1   # B = 1 for Curve25519 in Montgomery form
Fp = FiniteField(p)
E = EllipticCurve(Fp, [_sage_const_0 , A, _sage_const_0 , _sage_const_1 , _sage_const_0 ])  # Montgomery curve: By² = x³ + Ax² + x
Gx = Fp(_sage_const_9 )
rhs = Gx**_sage_const_3  + A*Gx**_sage_const_2  + Gx
y_candidates = rhs.sqrt(all=True)
Gy = y_candidates[_sage_const_0 ]
G = E(Gx, Gy)
k = _sage_const_0x1337c0decafe 
n = k.nbits()
def montgomery_ladder(P, k):
    R0 = P
    R1 = _sage_const_2 *P
    for i in reversed(range(n - _sage_const_1 )):
        if (k >> i) & _sage_const_1  == _sage_const_0 :
            R1 = R0 + R1
            R0 = _sage_const_2  * R0
        else:
            R0 = R0 + R1
            R1 = _sage_const_2  * R1
    return R0
Q = montgomery_ladder(G, k)
print(f"crypto{Q[_sage_const_0 ]}")


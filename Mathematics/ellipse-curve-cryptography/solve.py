from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from Crypto.Hash import SHA1
from Crypto.Util.number import inverse
from sympy import discrete_log

p = 173754216895752892448109692432341061254596347285717132408796456167143559
D = 529

Gx = 29394812077144852405795385333766317269085018265469771684226884125940148
Gy = 94108086667844986046802106544375316173742538919949485639896613738390948

Ax = 155781055760279718382374741001148850818103179141959728567110540865590463
Ay = 73794785561346677848810778233901832813072697504335306937799336126503714

Bx = 171226959585314864221294077932510094779925634276949970785138593200069419
By = 54353971839516652938533335476115503436865545966356461292708042305317630

g = Gx - 23*Gy % p
a = Ax - 23*Ay % p
b = Bx - 23*By % p
logaritm = discrete_log(p,a,g)
u = pow(b,logaritm,p)



x = ((u + inverse(u,p)) * inverse(2,p)) % p

key = SHA1.new(str(x).encode()).digest()[:16]

iv = bytes.fromhex('64bc75c8b38017e1397c46f85d4e332b')
ct = bytes.fromhex('13e4d200708b786d8f7c3bd2dc5de0201f0d7879192e6603d7c5d6b963e1df2943e3ff75f7fda9c30a92171bbbc5acbf')

cipher = AES.new(key, AES.MODE_CBC, iv)
flag = unpad(cipher.decrypt(ct),16).decode()
print(flag)

